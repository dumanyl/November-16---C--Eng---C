#include <Arduino.h>
#include "AFMotor_R4.h"

// ============================================================================
// MOTOR CONFIGURATION
// ============================================================================
AF_DCMotor leftMotor(1);   // Left motor on M1
AF_DCMotor rightMotor(2);  // Right motor on M2

// ============================================================================
// SENSOR CONFIGURATION
// ============================================================================
const int  SENSOR_PIN = 10;             // Digital sensor on servo header pin 10
const bool SENSOR_ACTIVE_HIGH = true;   // true: 1=tape/dark, 0=floor/light

// ============================================================================
// TURN DIRECTION CONFIGURATION
// ============================================================================
enum TurnDirection {
  TURN_LEFT,
  TURN_RIGHT
};

// Set this based on your track layout
TurnDirection currentTurnDirection = TURN_LEFT;  // Change to TURN_RIGHT if needed

// ============================================================================
// SPEED CONFIGURATION
// ============================================================================
const int MAX_SPEED        = 255;  // Straight-line top speed
const int SOFT_TURN_SPEED  = 220;  // Inner wheel speed during soft correction
const int HARD_TURN_SPEED  = 190;  // Inner wheel speed during hard correction
const int MIN_MOTOR_SPEED  = 150;  // Minimum speed to overcome friction

// ============================================================================
// TIMING CONFIGURATION
// ============================================================================
// Correction timing
const unsigned long SOFT_CORRECT_MIN_MS  = 60;   // Min time in soft correct
const unsigned long HARD_CORRECT_TH_MS   = 250;  // On tape this long => HARD_CORRECT
const unsigned long MIN_HARD_CORRECT_MS  = 120;  // Min time to stay in hard correct

// Lost-line detection
const unsigned long LOST_LINE_TH_MS      = 800;  // No tape this long => LOST_LINE
const unsigned long LOST_LINE_RECOVER_MS = 400;  // How long we arc-search in LOST_LINE

// Stage timing
const unsigned long SENSOR_WARMUP_MS          = 3000;  // Stage 0
const unsigned long COUNTDOWN_MS              = 2000;  // Stage 1
const unsigned long SENSOR_PRINT_INTERVAL_MS  = 100;   // Debug prints in Stage 2
const unsigned long FAST_BLINK_INTERVAL       = 200;   // Stage 0 LED blink
const unsigned long SLOW_BLINK_INTERVAL       = 500;   // Stage 1 LED blink

// (RAMP_UP_MS no longer used – we start at MAX_SPEED)

// ============================================================================
// DRIVE MODE STATE MACHINE
// ============================================================================
enum DriveMode {
  DRIVE_STRAIGHT,
  DRIVE_SOFT_CORRECT,
  DRIVE_HARD_CORRECT,
  DRIVE_LOST_LINE
};

DriveMode mode = DRIVE_STRAIGHT;

// ============================================================================
// GLOBAL TIMING VARIABLES
// ============================================================================
unsigned long bootTime          = 0;
unsigned long lastLedToggleTime = 0;
unsigned long lastSensorPrintTime = 0;
unsigned long modeStartTime     = 0;  // when current mode started
unsigned long tapeLastSeenTime  = 0;  // last time sensor saw tape
unsigned long stage2StartTime   = 0;  // when Stage 2 started
bool ledState = false;

// ============================================================================
// HELPER FUNCTION: Set Motor Speeds Based on Turn Direction (Forward Only)
// ============================================================================
void setMotorSpeedsWithTurn(int innerSpeed, int outerSpeed, TurnDirection direction) {
  // Clamp speeds
  innerSpeed = constrain(innerSpeed, 0, 255);
  outerSpeed = constrain(outerSpeed, 0, 255);

  // Apply minimum speed threshold (if >0)
  if (innerSpeed > 0 && innerSpeed < MIN_MOTOR_SPEED) {
    innerSpeed = MIN_MOTOR_SPEED;
  }
  if (outerSpeed > 0 && outerSpeed < MIN_MOTOR_SPEED) {
    outerSpeed = MIN_MOTOR_SPEED;
  }

  // Apply speeds based on turn direction (always FORWARD)
  if (direction == TURN_LEFT) {
    // Left turn: slow left motor, keep right fast
    leftMotor.setSpeed(innerSpeed);
    rightMotor.setSpeed(outerSpeed);
  } else {
    // Right turn: slow right motor, keep left fast
    leftMotor.setSpeed(outerSpeed);
    rightMotor.setSpeed(innerSpeed);
  }

  leftMotor.run(FORWARD);
  rightMotor.run(FORWARD);
}

// ============================================================================
// HELPER FUNCTION: Set Motor Speeds (Straight, Forward Only)
// ============================================================================
void setMotorSpeeds(int leftSpeed, int rightSpeed) {
  leftSpeed = constrain(leftSpeed, 0, 255);
  rightSpeed = constrain(rightSpeed, 0, 255);

  if (leftSpeed > 0 && leftSpeed < MIN_MOTOR_SPEED) {
    leftSpeed = MIN_MOTOR_SPEED;
  }
  if (rightSpeed > 0 && rightSpeed < MIN_MOTOR_SPEED) {
    rightSpeed = MIN_MOTOR_SPEED;
  }

  leftMotor.setSpeed(leftSpeed);
  rightMotor.setSpeed(rightSpeed);
  leftMotor.run(FORWARD);
  rightMotor.run(FORWARD);
}

// ============================================================================
// HELPER FUNCTION: Get Mode Name String
// ============================================================================
const char* modeToString(DriveMode m) {
  switch (m) {
    case DRIVE_STRAIGHT:      return "STRAIGHT";
    case DRIVE_SOFT_CORRECT:  return "SOFT_CORRECT";
    case DRIVE_HARD_CORRECT:  return "HARD_CORRECT";
    case DRIVE_LOST_LINE:     return "LOST_LINE";
    default:                  return "UNKNOWN";
  }
}

// ============================================================================
// SETUP
// ============================================================================
void setup() {
  Serial.begin(9600);
  delay(300);

  Serial.println("================================================");
  Serial.println("  Phase 5: Advanced Line Following Robot");
  Serial.println("  FORWARD ONLY, LEFT/RIGHT TURNING");
  Serial.println("================================================");
  Serial.println();
  Serial.print("Turn direction: ");
  Serial.println(currentTurnDirection == TURN_LEFT ? "LEFT" : "RIGHT");
  Serial.println();

  initMotorController();

  leftMotor.setSpeed(0);
  rightMotor.setSpeed(0);
  leftMotor.run(RELEASE);
  rightMotor.run(RELEASE);

  pinMode(SENSOR_PIN, INPUT);

  pinMode(LED_BUILTIN, OUTPUT);
  digitalWrite(LED_BUILTIN, HIGH);
  ledState = true;

  bootTime = millis();
  lastLedToggleTime = bootTime;
  lastSensorPrintTime = bootTime;
  mode = DRIVE_STRAIGHT;
  modeStartTime = bootTime;
  tapeLastSeenTime = bootTime;

  Serial.println("Starting Stage 0: Sensor warmup (3 seconds)");
  Serial.println();
}

// ============================================================================
// MAIN LOOP
// ============================================================================
void loop() {
  unsigned long now = millis();
  unsigned long elapsed = now - bootTime;

  // --------------------------------------------------------------------------
  // STAGE 0: SENSOR WARMUP (0–3000 ms)
  // --------------------------------------------------------------------------
  if (elapsed < SENSOR_WARMUP_MS) {

    static bool stage0MotorsInitialized = false;
    if (!stage0MotorsInitialized) {
      leftMotor.run(RELEASE);
      rightMotor.run(RELEASE);
      leftMotor.setSpeed(0);
      rightMotor.setSpeed(0);
      stage0MotorsInitialized = true;
    }

    if (now - lastLedToggleTime >= FAST_BLINK_INTERVAL) {
      ledState = !ledState;
      digitalWrite(LED_BUILTIN, ledState ? HIGH : LOW);
      lastLedToggleTime = now;
    }

    static unsigned long lastWarmupPrint = 0;
    if (now - lastWarmupPrint >= 250) {
      int raw = digitalRead(SENSOR_PIN);
      int onTape = SENSOR_ACTIVE_HIGH ? raw : !raw;

      Serial.print("Warmup: sensor = ");
      Serial.print(raw);
      Serial.print(" -> ");
      Serial.println(onTape == 1 ? "TAPE/DARK" : "FLOOR/LIGHT");

      lastWarmupPrint = now;
    }

    static bool warmupCompletePrinted = false;
    if (elapsed >= SENSOR_WARMUP_MS - 100 && !warmupCompletePrinted) {
      Serial.println();
      Serial.println("Stage 0 complete");
      Serial.println();
      warmupCompletePrinted = true;
    }
    return;
  }

  // --------------------------------------------------------------------------
  // STAGE 1: COUNTDOWN (3000–5000 ms)
  // --------------------------------------------------------------------------
  if (elapsed < SENSOR_WARMUP_MS + COUNTDOWN_MS) {
    unsigned long countdownElapsed = elapsed - SENSOR_WARMUP_MS;

    static bool stage1StartPrinted = false;
    if (!stage1StartPrinted) {
      Serial.println("Stage 1: Countdown (2 seconds)");
      Serial.println();
      stage1StartPrinted = true;
    }

    static bool stage1MotorsInitialized = false;
    if (!stage1MotorsInitialized) {
      leftMotor.run(RELEASE);
      rightMotor.run(RELEASE);
      leftMotor.setSpeed(0);
      rightMotor.setSpeed(0);
      stage1MotorsInitialized = true;
    }

    if (now - lastLedToggleTime >= SLOW_BLINK_INTERVAL) {
      ledState = !ledState;
      digitalWrite(LED_BUILTIN, ledState ? HIGH : LOW);
      lastLedToggleTime = now;
    }

    static bool countdown2Printed = false;
    static bool countdown1Printed = false;

    if (countdownElapsed < 1000 && !countdown2Printed) {
      Serial.println("Countdown: 2");
      countdown2Printed = true;
    } else if (countdownElapsed >= 1000 && !countdown1Printed) {
      Serial.println("Countdown: 1");
      countdown1Printed = true;
    }

    return;
  }

  // --------------------------------------------------------------------------
  // STAGE 2: LINE FOLLOWING (after 5000 ms)
  // --------------------------------------------------------------------------
  static bool stage2Initialized = false;
  if (!stage2Initialized) {
    digitalWrite(LED_BUILTIN, HIGH);

    Serial.println();
    Serial.println("================================================");
    Serial.println("  Stage 2: Line Following Active");
    Serial.println("  Forward only, soft/hard correction, lost-line");
    Serial.println("================================================");
    Serial.println();

    stage2StartTime = now;
    mode = DRIVE_STRAIGHT;
    modeStartTime = now;
    tapeLastSeenTime = now;

    stage2Initialized = true;
    lastSensorPrintTime = now;
  }

  // 1. READ SENSOR
  int raw = digitalRead(SENSOR_PIN);
  int onTape = SENSOR_ACTIVE_HIGH ? raw : !raw;  // 1 = tape, 0 = floor

  if (onTape) {
    tapeLastSeenTime = now;
  }

  // 2. BASE SPEED – ALWAYS MAX (no ramp)
  int baseSpeed = MAX_SPEED;

  // 3. LOST-LINE CHECK
  unsigned long timeSinceTape = now - tapeLastSeenTime;
  if (timeSinceTape >= LOST_LINE_TH_MS && mode != DRIVE_LOST_LINE) {
    mode = DRIVE_LOST_LINE;
    modeStartTime = now;
    Serial.println(">> LOST_LINE: entering recovery mode");
  }

  // 4. DRIVE MODE LOGIC
  unsigned long inMode = now - modeStartTime;

  switch (mode) {

    case DRIVE_STRAIGHT:
      setMotorSpeeds(baseSpeed, baseSpeed);
      if (onTape == 1) {
        mode = DRIVE_SOFT_CORRECT;
        modeStartTime = now;
        Serial.print(">> Mode: SOFT_CORRECT (saw tape, turning ");
        Serial.print(currentTurnDirection == TURN_LEFT ? "LEFT" : "RIGHT");
        Serial.println(")");
      }
      break;

    case DRIVE_SOFT_CORRECT:
      setMotorSpeedsWithTurn(SOFT_TURN_SPEED, baseSpeed, currentTurnDirection);

      if (onTape && inMode >= HARD_CORRECT_TH_MS) {
        mode = DRIVE_HARD_CORRECT;
        modeStartTime = now;
        Serial.println(">> Mode: HARD_CORRECT (tape persisting)");
      } else if (!onTape && inMode >= SOFT_CORRECT_MIN_MS) {
        mode = DRIVE_STRAIGHT;
        modeStartTime = now;
        Serial.println(">> Mode: STRAIGHT (back on floor)");
      }
      break;

    case DRIVE_HARD_CORRECT:
      setMotorSpeedsWithTurn(HARD_TURN_SPEED, baseSpeed, currentTurnDirection);

      if (inMode >= MIN_HARD_CORRECT_MS && !onTape) {
        mode = DRIVE_STRAIGHT;
        modeStartTime = now;
        Serial.println(">> Mode: STRAIGHT (correction complete)");
      }
      break;

    case DRIVE_LOST_LINE:
      // Recovery: forward arc in currentTurnDirection (no backward / no spin in place)
      // Just a more aggressive version of SOFT_CORRECT
      setMotorSpeedsWithTurn(HARD_TURN_SPEED, baseSpeed, currentTurnDirection);

      if (onTape == 1) {
        mode = DRIVE_STRAIGHT;
        modeStartTime = now;
        tapeLastSeenTime = now;
        Serial.println(">> LOST_LINE: Found tape! -> STRAIGHT");
      } else if (inMode >= LOST_LINE_RECOVER_MS * 2) {
        // Optional: flip direction if we’ve been lost too long
        currentTurnDirection = (currentTurnDirection == TURN_LEFT) ? TURN_RIGHT : TURN_LEFT;
        modeStartTime = now;
        Serial.print(">> LOST_LINE: Switching search direction to ");
        Serial.println(currentTurnDirection == TURN_LEFT ? "LEFT" : "RIGHT");
      }
      break;
  }

  // 5. DEBUG PRINT
  if (now - lastSensorPrintTime >= SENSOR_PRINT_INTERVAL_MS) {
    Serial.print("sensor = ");
    Serial.print(raw);
    Serial.print(" -> ");
    Serial.print(onTape == 1 ? "TAPE" : "FLOOR");
    Serial.print(", mode = ");
    Serial.print(modeToString(mode));
    Serial.print(", direction = ");
    Serial.println(currentTurnDirection == TURN_LEFT ? "LEFT" : "RIGHT");
    lastSensorPrintTime = now;
  }
}
